Стек данных
Стек возврата: Используется для хранения адресов возврата при вызове подпрограмм
Регистры A и B: Это дополнительные регистры, которые можно использовать для хранения адресов или данных


Размер инструкции:
    1 байт для кода операции
    4 байта для каждого аргумента

lit <value>     Немедленно помещает значение в стек данных                                          dataStack.push(<value>)
@p <address>    Поместить значение с определенного адреса в стек данных                             dataStack.push(mem[<address>])
@               Поместить значение из адреса в регистре A в стек данных                             dataStack.push(mem[A])
@+              Поместить значение из адреса в регистре A в стек данных и увеличить A               dataStack.push(mem[A]); A <- A + 1
@b              Поместить значение из адреса в регистре B в стек данных                             dataStack.push(mem[B])
!p <address>    Сохранение верхнего значения стека данных по определенному адресу                   mem[<address>] <- dataStack.pop()
!               Сохранение верхнего значения стека данных по адресу в регистре A                    mem[A] <- dataStack.pop()
!+              Сохранение верхнего значения стека данных по адресу в регистре A и увеличение A     mem[A] <- dataStack.pop(); A <- A + 1
!b              Сохранение верхнего значения стека данных по адресу в регистре B                    mem[B] <- dataStack.pop()
a!              Сохранение верхнего значения стека данных в регистре A                              A <- dataStack.pop()
b!              Сохранение верхнего значения стека данных в регистре B                              B <- dataStack.pop()
a               Поместить значение регистра A в стек данных                                         dataStack.push(A)

+       Сложить два верхних значения в стеке данных
        Инструкция + выполняет сложение двух верхних значений в стеке данных. В зависимости от состояния флага EAM
        (Extended Arithmetic Mode, расширенный арифметический режим), сложение может учитывать или не учитывать значение
        флага переноса (carry flag).
        EAM (Extended Arithmetic Mode) — это флаг или режим, который указывает, нужно ли учитывать флаг переноса (carry flag)
        при выполнении арифметических операций. Флаг переноса используется для работы с числами, которые больше, чем может
        вместить один регистр или ячейка памяти (например, при сложении больших чисел).
        EAM = 0 (выключен): Флаг переноса не учитывается. Сложение выполняется как обычное сложение двух чисел.
        EAM = 1 (включен): Флаг переноса учитывается. К результату сложения добавляется значение флага переноса.

        ЗАЧЕМ НУЖЕН EAM?
        EAM полезен при работе с большими числами, которые не помещаются в один регистр или ячейку памяти.
        Например, если вы складываете два 64-битных числа на 32-битной архитектуре, вам нужно учитывать
        перенос из младших битов в старшие. В этом случае EAM позволяет корректно выполнять такие операции.

            no EAM:     dataStack.push(dataStack.pop() + dataStack.pop()), set carry flag
                        Из стека данных извлекаются два верхних значения.
                        Эти значения складываются.
                        Результат сложения помещается обратно в стек данных.
                        Флаг переноса (carry flag) устанавливается в зависимости от результата сложения (например, если произошло переполнение).
            
            EAM:        dataStack.push(dataStack.pop() + dataStack.pop() + carry), set carry flag
                        Из стека данных извлекаются два верхних значения.
                        Эти значения складываются.
                        К результату сложения добавляется значение флага переноса (carry flag).
                        Результат помещается обратно в стек данных.
                        Флаг переноса обновляется в зависимости от нового результата.

+*      Выполнить действие умножения                                T <- T + (if A[0] then S else 0); A <- A >> 1; if T[0] then A[31] <- 1 else A[31] <- 0; T <- T >> 1
            T <- T + if A[0] then S else 0       
            Проверяется младший бит регистра A (A[0]).
            Если A[0] == 1, то к аккумулятору T добавляется значение регистра S.
            Если A[0] == 0, то к аккумулятору T добавляется 0.
            (Младший бит A[0] указывает, нужно ли добавлять множимое (S) к промежуточному результату (T).
            Это часть алгоритма умножения, где мы "накапливаем" результат, добавляя S только тогда, когда текущий бит множителя (A[0]) равен 1.)

            A <- A >> 1
            Регистр A сдвигается вправо на один бит.
            Младший бит (A[0]) теряется, а старший бит заполняется нулем.
            Сдвиг вправо позволяет перейти к следующему биту множителя (A).
            Это необходимо для обработки всех битов множителя по очереди.

            if T[0] then A[31] <- 1 else A[31] <- 0
            Проверяется младший бит аккумулятора T (T[0]).
            Если T[0] == 1, то старший бит регистра A (A[31]) устанавливается в 1.
            Если T[0] == 0, то старший бит регистра A (A[31]) устанавливается в 0.
            При сдвиге аккумулятора T вправо младший бит (T[0]) "теряется". Чтобы сохранить эту информацию, она переносится в старший бит регистра A.
            Это важно для корректного выполнения умножения, особенно при работе с большими числами.

            T <- T >> 1
            Аккумулятор T сдвигается вправо на один бит.
            Младший бит (T[0]) теряется, а старший бит заполняется нулем.
            Сдвиг вправо подготавливает аккумулятор T для следующей итерации.
            Это позволяет корректно накапливать результат умножения.
+/      Выполнить шаг деления                                       remainder <- remainder << 1; if dividend[31] then remainder[0] <- 1; dividend <- dividend << 1; if remainder >= divisor then remainder <- remainder - divisor; quotient <- quotient << 1; if remainder >= divisor then quotient[0] <- 1
            remainder <- remainder << 1
            Остаток (remainder) сдвигается влево на один бит.
            Младший бит (remainder[0]) заполняется нулем.
            Сдвиг влево позволяет "освободить" младший бит остатка для записи нового бита из делимого (dividend).

            if dividend[31] then remainder[0] <- 1
            Проверяется старший бит делимого (dividend[31]).
            Если dividend[31] == 1, то младший бит остатка (remainder[0]) устанавливается в 1.
            Старший бит делимого (dividend[31]) переносится в младший бит остатка (remainder[0]).
            Это позволяет корректно "переносить" биты из делимого в остаток.

            dividend <- dividend << 1
            Делимое (dividend) сдвигается влево на один бит.
            Младший бит (dividend[0]) заполняется нулем.
            Сдвиг влево позволяет перейти к следующему биту делимого на следующей итерации.

            if remainder >= divisor then remainder <- remainder - divisor
            Проверяется, больше или равен ли остаток (remainder) делителю (divisor).
            Если remainder >= divisor, то из остатка вычитается делитель.
            Если остаток больше или равен делителю, это означает, что текущий бит частного должен быть 1.
            Вычитание делителя из остатка корректирует остаток для следующей итерации.

            quotient <- quotient << 1
            Частное (quotient) сдвигается влево на один бит.
            Младший бит (quotient[0]) заполняется нулем.
            Сдвиг влево позволяет "освободить" младший бит частного для записи нового бита.


            if remainder >= divisor then quotient[0] <- 1
            Проверяется, больше или равен ли остаток (remainder) делителю (divisor).
            Если remainder >= divisor, то младший бит частного (quotient[0]) устанавливается в 1.
            Если остаток больше или равен делителю, это означает, что текущий бит частного должен быть 1.
            Установка младшего бита частного в 1 фиксирует этот факт.
2*      Сдвиг верхнего значения стека данных влево на один бит      dataStack.push(dataStack.pop() << 1)
2/      Сдвиг верхнего значения стека данных вправо на один бит     dataStack.push(dataStack.pop() >> 1)
inv     Инвертировать все биты верхнего значения в стеке данных     dataStack.push(~dataStack.pop())
eam     Извлечение значения из стека данных и установка флага EAM   eam <- dataStack.pop()

and     Выполнение побитовой операции «И» над двумя верхними значениями стека данных    dataStack.push(dataStack.pop() & dataStack.pop())
xor     Выполнить побитовую операцию XOR над двумя верхними значениями стека данных     dataStack.push(dataStack.pop() ^ dataStack.pop())
drop    Удалить верхнее значение из стека данных                                        dataStack.pop()
dup     Дублирование верхнего значения стека данных                                     dataStack.push(dataStack.top()), carry flag does not change
over    Поменять местами два верхних значения стека данных                              T <- dataStack.pop(); S <- dataStack.pop(); dataStack.push(T); dataStack.push(S)

;               Возврат из подпрограммы                         p <- returnStack.pop()
<label>         Вызов подпрограммы по указанной метке           returnStack.push(p); p <- <label>
<label> ;       Переход к указанной метке                       p <- <label>
next <label>    Перейти к указанной метке, уменьшая R           if R != 0 then R <- R - 1; p <- <label>
if <label>      Переход к указанной метке, если верхнее значение стека данных равно нулю        if dataStack.pop() == 0 then p <- <label>
-if <label>     Переход к указанной метке, если верхнее значение стека данных неотрицательно    if dataStack.pop() >= 0 then p <- <label>
halt            Остановите машину

r>      Переместить верхнее значение стека возврата в стек данных       dataStack.push(returnStack.pop())
>r      Переместить верхнее значение стека данных в стек возврата       returnStack.push(dataStack.pop())



Carry выставляется, если происходит перенос или заем при выполнении арифметической операции. Это может происходить в следующих случаях:
    Для беззнаковых чисел (unsigned):
    Сложение: Если результат сложения двух чисел превышает максимальное значение, которое можно представить в заданном количестве бит.
    0xFF (255) + 0x01 (1) = 0x100 (256)
    Вычитание: Если результат вычитания меньше нуля (происходит заем).
    0x00 (0) - 0x01 (1) = 0xFF (255)

Overflow выставляется, если результат арифметической операции не может быть корректно представлен в заданном количестве бит для знаковых чисел (signed).
    Для знаковых чисел (signed):
    Сложение: Если результат сложения двух положительных чисел дает отрицательное число, или если сложение двух отрицательных чисел дает положительное число.
    0x7F (127) + 0x01 (1) = 0x80 (-128)
    Вычитание: Если результат вычитания выходит за пределы диапазона.
    0x80 (-128) - 0x01 (1) = 0x7F (127)
    Overflow:
    	+ - *
    	/ не выставляет


Переполнение может быть (когда в квадрат возведется) (2^16+1)^2 а это больше чем 2^32
