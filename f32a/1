.data

input_address: .word 0x80
output_address: .word 0x84
overflow_value: .word 0xCCCCCCCC

.text

\ формула: k(k+1), k = m/2 - сумма четных чисел

read_address:   \ read_address(addr)
    a!          \ Берет верхнее значение стека (адрес) и сохраняет его в регистре A, Регистр A используется для хранения адреса, по которому нужно прочитать значение из памяти
    @           \ Читает значение из памяти по адресу, который находится в регистре A, и помещает его в стек
    ;           \ Возврат из функции

write_address:  \ write_address(addr, value)
    a!          \ Берет верхнее значение стека (адрес) и сохраняет его в регистре A, Регистр A используется для хранения адреса, по которому нужно записать значение
    !           \ Сохраняет верхнее значение стека (значение) по адресу, который находится в регистре A.
    ;           \ Возврат из функции

mul:            \ (a, b) -> a*b, a - value in A register, b - second value from top of the stack
    lit 0               \ Помещает 0 в стек, Это старшая часть результата умножения, которая в данном случае не используется, Стек теперь содержит [0]
    lit 31              \ Помещает 31 в стек Это количество итераций для выполнения умножения (32 бита, но счетчик начинается с 0), Стек теперь содержит [31, 0]
    >r                  \ Перемещает верхнее значение стека (31) в стек возврата, Мы будем использовать это значение как счетчик итераций, Стек возврата теперь содержит [31], а стек данных содержит [0]
mul_loop:                 \ Цикл умножения
    +*                  \ Это специальная инструкция, которая выполняет один шаг умножения. Она работает следующим образом:
                        \ Берет два верхних значения стека (частичный результат и текущий бит множителя).
                        \ Если текущий бит множителя равен 1, добавляет множимое к частичному результату.
                        \ Сдвигает множимое и частичный результат вправо на один бит.
                        \ Мы хотим выполнить умножение пошагово, обрабатывая каждый бит множителя
                        \ Результат: Частичный результат умножения обновляется
    
    next mul_loop         \ Повторяет цикл, пока значение в стеке возврата не станет нулем
                        \ Уменьшает значение в стеке возврата на 1 и, если оно не равно 0, переходит к метке mul_loop
                        \ Мы хотим повторить цикл умножения 32 раза (по одному разу для каждого бита)
                        \Цикл повторяется, пока счетчик итераций не станет равным 0.
    
    over                \ Копирует второе значение стека (частичный результат) на вершину стека, Мы хотим проверить, не произошло ли переполнение, Стек теперь содержит [частичный результат, частичный результат]
    drop                \ Удаляет верхнее значение стека, Мы хотим оставить только один экземпляр частичного результата, Стек теперь содержит [частичный результат]
    if mul_no_overflow             \ Если верхнее значение стека (частичный результат) равно 0 (НЕ ПЕРЕПОЛНИЛОСЬ), переходит к метке mul_no_overflow
    @p overflow_value   \ Если произошло переполнение, помещает значение переполнения в стек
    ;                   \ Возврат из функции
mul_no_overflow:                   \ Продолжение выполнения, если переполнения не было
    a                   \ Помещает значение регистра A в стек, Мы хотим вернуть результат умножения, Стек теперь содержит [результат умножения]
    dup                 \ Дублирует верхнее значение стека, Мы хотим проверить, не является ли результат отрицательным, Стек теперь содержит [результат умножения, результат умножения]
    -if mul_no_negative            \ Если результат умножения неотрицательный, переходит к метке mul_no_negative, Мы хотим проверить, не произошло ли переполнение
    drop                \ Удаляет верхнее значение стека, Мы хотим оставить только один экземпляр результата
    @p overflow_value   \ Если результат отрицательный, помещает значение переполнения в стек
    ;                   \ Возврат из функции
mul_no_negative:                   \ Продолжение выполнения, если результат неотрицательный
    ;                   \ Возврат из функции

square: \ x*x
    dup                 \ Дублирует значение x, Стек теперь содержит [x, x]
    a!                  \ Сохраняет значение x в регистр A
    mul                 \ Вызывает функцию умножения
    ;                   \ Возврат из функции

is_valid:   \is_valid(n), checks if n > 0, returns 0 if yes, -1 otherwise
    dup                 \ Дублирует значение n, Мы хотим сохранить исходное значение n, потому что оно понадобится позже для проверки. После дублирования стек выглядит так: [n, n].
    lit -1              \ Помещает -1 в стек - [n, n, -1]
    +                   \ Вычитает 1 из n (n - 1) | Мы хотим проверить, является ли n положительным числом. Если n > 0, то n - 1 будет неотрицательным (n - 1 >= 0). Если n <= 0, то n - 1 будет отрицательным.
    -if true            \ Если результат неотрицательный (n > 0), переходит к метке true
false:                  
    lit -1              \ Если n <= 0, помещает -1 в стек
    ;
true:
    lit 0               \ Если n > 0, помещает 0 в стек
    ;

compare:    \ compare(a, b), returns 0 if a == b, 1 otherwise, doesnt duplicate stack values
    inv         \ Инвертирует все биты верхнего значения стека (a),  Мы хотим вычислить -a - 1, что эквивалентно ~a, Стек теперь содержит [~a, b]
    lit 1       \ Помещает 1 в стек, Мы хотим вычислить -a, Стек теперь содержит [1, ~a, b]
    +           \ Добавляет 1 к инвертированному значению a (эквивалентно -a), Стек теперь содержит [-a, b]
    +           \ Сравнивает -a и b (эквивалентно b - a), Стек теперь содержит [b-a]
    if equal    \ Если результат (b-a) равен 0 (a == b), переходит к метке equal
not_equal:
    lit 1       \ Если a != b, помещает 1 в стек
    ;     
equal:
    lit 0       \ Если a == b, помещает 0 в стек
    ;     
    

_start:
    @p input_address            \ Читает значение из input_address и помещает его в стек
    read_address                \ Вызывает функцию read_address для чтения значения n

    is_valid                    \ Проверяет, что n > 0
    if good_value
bad_value:
    lit -1                      \ Если n <= 0, переходит к метке bad_value и возвращает -1.
    end ;
good_value:                     \ Если n > 0, переходит к метке good_value.
    2/                          \ Делит n на 2 (эквивалентно n // 2), мы вычисляем k, где k = n/2, где k - количество четных чисел от 0 до n
    dup                         \ Дублирует результат, Мы хотим сохранить значение k, чтобы использовать его позже для сложения [k, k]
    square                      \ Вычисляет квадрат k, так как формула: k^2 + k, Стек теперь содержит [k^2, k]

    dup                         \ Дублирует результат, Мы хотим сохранить значение k^2, чтобы сравнить его с overflow_value, [k^2, k^2, k]
    @p overflow_value           \ Помещает значение переполнения в стек, Стек теперь содержит [overflow_value, k^2, k^2, k]
    compare                     \ Сравнивает два верхних значения стека (k^2 и overflow_value), Стек теперь содержит [результат сравнения, k^2, k]
    if overflow                 \ Если результат равен overflow_value, переходит к метке overflow
    +                           \ Складывает два верхних значения стека (k^2 и k)
    end                         \ Переход к завершению программы
    ;
overflow:
    @p overflow_value           \ Если произошло переполнение, помещает overflow_value в стек
end:
    @p output_address           \ Помещает адрес output_address в стек
    write_address               \ Записывает результат по адресу output_address
    halt                        \ Останавливает выполнение программы