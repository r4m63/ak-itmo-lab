.data

input_address: .word 0x80
output_address: .word 0x84
overflow_value: .word 0xCCCCCCCC

.text

\ формула: k(k+1), k = m/2 - сумма четных чисел

read_address:   \ read_address(addr)
    a!          \ Сохраняет адрес из стека данных в регистр A.
    @           \ Читает значение из памяти по адресу в регистре A и помещает его в стек данных.
    ;           \ Возврат из функции

write_address:  \ write_address(addr, value)
    a!          \ Сохраняет адрес из стека данных в регистр A
    !           \ Сохраняет значение из стека данных по адресу в регистре A
    ;           \ Возврат из функции

mul:            \ (a, b) -> a*b, a - value in A register, b - second value from top of the stack
                \ High part of the multiplication result (NOT USED)
    lit 0               \ Помещает 0 в стек (старшая часть результата умножения, не используется)
    lit 31              \ Помещает 31 в стек (количество итераций для умножения)
    >r                  \ Перемещает 31 в стек возврата
mul_do:                 \ Цикл умножения
    +*                  \ Выполняет шаг умножения
    next mul_do         \ Повторяет цикл, пока значение в стеке возврата не станет нулем
    over                \ Копирует верхнее значение стека
    drop                \ Удаляет верхнее значение стека
    if ok_1             \ Если результат умножения не переполнен, переходит к метке ok_1
    @p overflow_value   \ Если произошло переполнение, помещает значение переполнения в стек
    ;                   \ Возврат из функции
ok_1:                   \ Продолжение выполнения, если переполнения не было
    a                   \ Помещает значение регистра A в стек
    dup                 \ Дублирует верхнее значение стека
    -if ok_2            \ Если результат неотрицательный, переходит к метке ok_2
    drop                \ Удаляет верхнее значение стека
    @p overflow_value   \ Если результат отрицательный, помещает значение переполнения в стек
    ;                   \ Возврат из функции
ok_2:                   \ Продолжение выполнения, если результат неотрицательный
    ;                   \ Возврат из функции

square: \ x*x
    dup                 \ Дублирует значение x
    a!                  \ Сохраняет значение x в регистр A
    mul                 \ Вызывает функцию умножения
    ;                   \ Возврат из функции

is_valid:   \is_valid(n), checks if n > 0, returns 0 if yes, -1 otherwise
    dup                 \ Дублирует значение n
    lit -1              \ Помещает -1 в стек
    +                   \ Вычитает 1 из n (n - 1)
    -if true            \ Если результат неотрицательный (n > 0), переходит к метке true
false:                  
    lit -1              \ Если n <= 0, помещает -1 в стек
    ;
true:
    lit 0               \ Если n > 0, помещает 0 в стек
    ;

compare:    \ compare(a, b), returns 0 if a == b, 1 otherwise, doesn't duplicate stack values
    inv         \ Инвертирует значение a.
    lit 1       \ Помещает 1 в стек
    +           \ Добавляет 1 к инвертированному значению a (эквивалентно -a)
    +           \ Сравнивает -a и b (эквивалентно b - a)
    if equal    \ Если результат равен 0 (a == b), переходит к метке equal
not_equal:
    lit 1       \ Если a != b, помещает 1 в стек
    ;     
equal:
    lit 0       \ Если a == b, помещает 0 в стек
    ;     
    

_start:
    @p input_address            \ Читает значение из input_address и помещает его в стек
    read_address                \ Вызывает функцию read_address для чтения значения n

    is_valid                    \ Проверяет, что n > 0
    if good_value
bad_value:
    lit -1                      \ Если n <= 0, переходит к метке bad_value и возвращает -1.
    end ;
good_value:                     \ Если n > 0, переходит к метке good_value.
    2/                          \ Делит n на 2 (эквивалентно n // 2)
    dup                         \ Дублирует результат
    square                      \ Вычисляет квадрат результата (эквивалентно (n // 2) * (n // 2))

    \ if (stack.top() == overflow_value)
    dup                         \ Дублирует результат
    @p overflow_value           \ Помещает значение переполнения в стек
    compare                     \ Сравнивает результат с overflow_value
    if overflow                 \ Если результат равен overflow_value, переходит к метке overflow
    +                           \ Складывает результат с n // 2 (эквивалентно (n // 2) * (n // 2) + (n // 2))
    end                         \ Завершает выполнение
    ;
overflow:
    @p overflow_value           \ Если произошло переполнение, помещает overflow_value в стек
end:
    @p output_address           \ Сохраняет результат в output_address и завершает выполнение программы
    write_address
    halt