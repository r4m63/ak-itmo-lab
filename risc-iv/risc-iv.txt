def count_ones(n):
    """Count the number of ones in the binary representation of a number"""
    count = 0
    while n > 0:
        count += n & 1
        n >>= 1
    return count


assert count_ones(5) == 2
assert count_ones(7) == 3
assert count_ones(247923789) == 13
assert count_ones(2147483647) == 31


https://wrench.edu.swampbuds.me/result/4646c292-e745-4ed0-8cff-a746e95532b7


Эти директивы обычно используются вместе для загрузки полного 32-битного адреса в регистр:
```
lui  a0, %hi(address)    ; Load upper 20 bits into a0
addi a0, a0, %lo(address) ; Add lower 12 bits to a0
```
%hi(symbol)             Используется для извлечения старших 20 бит 32-битного адреса или непосредственного значения
                        Использование: lui rd, %hi(symbol)
                        Операция: rd <- (symbol & 0xFFFFF000)
%lo(symbol)             Используется для извлечения младших 12 бит 32-битного адреса или непосредственного значения
                        Использование: addi rd, rs, %lo(symbol)
                        Операция: rd <- rs + (symbol & 0x00000FFF)
Эти директивы решают ключевую проблему RISC-архитектуры: загрузку 32-битных адресов/констант при том, что:
Обычные команды (вроде addi) поддерживают только 12-битные immediate-значения (константы, которые встроены прямо в машинный код инструкций. Они используются в RISC-V для операций, где один из операндов является фиксированным числом, а не значением из регистра.)
32-битный адрес нельзя загрузить одной инструкцией
-----
lui  rd, %hi(symbol)    # Загрузка старших 20 бит
addi rd, rd, %lo(symbol) # Добавление младших 12 бит
lui  a0, %hi(0x12345678)   # a0 = 0x12345000 (0x12345 << 12)
addi a0, a0, %lo(0x12345678) # a0 = 0x12345000 + 0x678 = 0x12345678
-----
Почему именно 20 + 12 бит?
RISC-V использует эту схему, потому что:
lui (Load Upper Immediate)
Загружает 20-битное значение в биты 12-31 регистра
Младшие 12 бит (0-11) обнуляются
Формат: lui rd, imm20 → rd = imm20 << 12

addi
Добавляет 12-битное signed immediate (со знаком)
Диапазон: -2048..2047 (0x800..0x7FF)
Комбинация дает полный 32-битный диапазон
20 бит (lui) × 4096 (2¹²) = покрывает весь 32-битный адресный диапазон

Размер инструкции: 4 байта.

lui <rd>, <k>       (Load Upper Immediate) Загрузка непосредственного значения, сдвинутого влево на 12 бит, в регистр назначения.
    rd <- k << 12

    Зачем нужен сдвиг на 12 бит?
    Причина 1: Формирование 32-битных адресов
    RISC-V — это 32-битная (или 64-битная) архитектура, но immediate-значения в командах ограничены по длине.
    Обычные команды (addi, lw, sw) поддерживают только 12-битные immediate-значения (от -2048 до 2047).
    Но для работы с 32-битными адресами (например, при загрузке данных из памяти) 12 бит недостаточно.
    lui загружает старшие 20 бит адреса (imm20), сдвигая их влево на 12 бит.
    Затем addi или lw/sw добавляет младшие 12 бит (imm12).
    lui t0, %hi(0x12345678)   # t0 = 0x12345000
    addi t0, t0, %lo(0x12345678)  # t0 = 0x12345000 + 0x678 = 0x12345678

    Причина 2: Эффективное использование immediate-значений
    В RISC-V большинство immediate-значений в командах (addi, lw, sw) имеют длину 12 бит.
    Но иногда нужно загрузить большие константы (например, 0xDEADBEEF).
    lui позволяет загрузить верхние 20 бит, а затем addi добавляет нижние 12 бит.
    lui t0, 0xDEADB   # t0 = 0xDEADB000
    addi t0, t0, 0xEEF  # t0 = 0xDEADBEEF

    Причина 3: Поддержка относительной адресации
    В RISC-V нет абсолютных переходов (jmp 0x12345678).
    Вместо этого используется комбинация lui + jalr (Jump And Link Register).
    Пример перехода по абсолютному адресу:
    lui t0, %hi(target_address)  # загружаем старшие 20 бит
    jalr ra, %lo(target_address)(t0)  # прыгаем по адресу t0 + imm12

    Почему именно 20 + 12 бит?
    20 бит (для lui) + 12 бит (для addi/lw) = 32 бита → покрывает весь адресный диапазон.
    Это оптимально для RISC-архитектуры, где команды имеют фиксированную длину (32 бита).
    Альтернативы (например, загружать 32 бита сразу) потребовали бы двух команд в любом случае, но с lui это делается более эффективно.

mv <rd>, <rs>       Переместить значение из исходного регистра в целевой регистр.
    rd <- rs
    ассемблер автоматически заменяет её на:
    addi rd, rs, 0   # rd = rs + 0


sw <rs2>, <offset>(<rs1>)       Сохранение значения из исходного регистра в памяти по адресу, вычисленному путем прибавления смещения к базовому регистру.
    M[offset + rs1] <- rs2
    -----
    sw rs2, offset(rs1)
    где:
    rs2 — исходный регистр, чьё значение сохраняется в память
    offset — 12-битное знаковое смещение (-2048..2047)
    rs1 — базовый регистр, содержащий адрес в памяти
    -----
    Вычисление адреса:
    Адрес в памяти = Значение из rs1 + offset
    Сохранение данных:
    4 байта (32 бита) из регистра rs2 записываются по вычисленному адресу


sb <rs2>, <offset>(<rs1>)       Сохранение младших 8 бит значения из исходного регистра в памяти по адресу, вычисленному путем прибавления смещения к базовому регистру.
    M[offset + rs1] <- rs2 & 0xFF
    Store Byte
    Адрес памяти = rs1 + offset
    Только младшие 8 бит (биты 7:0) регистра rs2 записываются в память
    Даже если в rs2 хранится 32-битное значение (например, 0x12345678), сохранится только 0x78.

lw <rd>, <offset>(<rs1>)    Загрузка слова из памяти по адресу, вычисленному путем добавления смещения к базовому регистру в регистр назначения.
    rd <- M[offset + rs1]
    Вычисление адреса:
    Адрес памяти = rs1 + offset
    Чтение данных:
    Из памяти по вычисленному адресу загружается 4 последовательных байта (32 бита) и записываются в регистр rd.

addi <rd>, <rs1>, <k>   Добавить непосредственное значение в исходный регистр и сохранить результат в регистре назначения. Сохраняются только нижние 12 бит результата (верхние 20 бит устанавливаются в зависимости от знака непосредственного значения).
    rd <- rs1 + k
    -----
    addi <rd>, <rs1>, <imm12>
    rd — регистр-приёмник (куда записывается результат)
    rs1 — исходный регистр
    imm12 — 12-битное знаковое число (-2048..2047)
    -----
    Как это работает?
    Знаковое расширение:
    12-битное imm12 расширяется до 32 бит с сохранением знака.
    Например, imm12 = 0xFFF (-1) → 0xFFFFFFFF
    imm12 = 0x7FF (2047) → 0x000007FF
    Сложение:
    Производится сложение rs1 и расширенного imm12.
    Запись результата:
    Результат записывается в rd.
    -----
    12-битное ограничение:
    imm12 может быть только в диапазоне -2048..2047.
    Для больших значений используйте комбинацию lui + addi:


add <rd>, <rs1>, <rs2>  Сложить значения двух исходных регистров и сохранить результат в целевом регистре.
    rd <- rs1 + rs2

sub <rd>, <rs1>, <rs2>  Вычесть значение второго исходного регистра из значения первого исходного регистра и сохранить результат в целевом регистре.
    rd <- rs1 - rs2

mul <rd>, <rs1>, <rs2>  Умножение значений двух исходных регистров и сохранение результата в целевом регистре.
    rd <- rs1 * rs2

mulh <rd>, <rs1>, <rs2> Умножить значения двух исходных регистров и сохранить старшую часть результата в целевом регистре.
    rd <- (rs1 * rs2) >> (word size)
    -----
    Выполняет знаковое умножение двух 32-битных регистров и сохраняет старшие 32 бита 64-битного результата в целевом регистре.
    Это критически важно для корректной работы с большими числами, где результат умножения не помещается в 32 бита.
    -----
    Формат команды
    mulh <rd>, <rs1>, <rs2>
    rd — регистр для старшей части результата
    rs1, rs2 — исходные регистры (множители)
    Формула:
    rd = (rs1 * rs2) >> 32
    где:
    rs1 * rs2 — 64-битный результат умножения
    >> 32 — сдвиг вправо на 32 бита (чтобы оставить только старшую часть)

    Как это работает?
    Знаковое умножение:
    rs1 и rs2 интерпретируются как 32-битные знаковые числа (в формате int32_t).
    Результат умножения — 64-битное знаковое число (int64_t).
    Извлечение старшей части:
    Старшие 32 бита 64-битного результата записываются в rd.
    Младшая часть:
    Если нужна младшая часть, используйте mul (она сохраняет младшие 32 бита).

    Примеры
    1. Умножение с переполнением
    li t0, 0x70000000   # t0 = 1879048192 (большое положительное)
    li t1, 0x2          # t1 = 2
    mulh t2, t0, t1     # t2 = старшие 32 бита (0x00000001)
    mul t3, t0, t1      # t3 = младшие 32 бита (0xE0000000)
    Результат:
    Полный 64-битный результат: 0x00000001_E0000000
    t2 = 0x00000001 (старшая часть)
    t3 = 0xE0000000 (младшая часть)
    2. Умножение отрицательных чисел
    li t0, -1000        # t0 = 0xFFFFFC18
    li t1, 1000         # t1 = 0x000003E8
    mulh t2, t0, t1     # t2 = 0xFFFFFFFF (-1)
    mul t3, t0, t1      # t3 = 0xFFFFF448 (-1000000 % 2^32)
    Объяснение:
    Полный результат: -1_000_000 (в 64 битах: 0xFFFFFFFFFFF0BDC0)
    Старшие 32 бита: 0xFFFFFFFF (-1 в дополнительном коде)


div <rd>, <rs1>, <rs2>  Разделить значение первого исходного регистра на значение второго исходного регистра и сохранить результат в целевом регистре.
    rd <- rs1 / rs2

rem <rd>, <rs1>, <rs2>  Вычислить остаток от деления первого исходного регистра на второй исходный регистр и сохранить результат в целевом регистре.
    rd <- rs1 % rs2


sll <rd>, <rs1>, <rs2> Логический сдвиг влево Сдвиг значения первого исходного регистра влево на количество бит, указанное во втором исходном регистре, и сохранение результата в целевом регистре.
    rd <- rs1 << rs2

srl <rd>, <rs1>, <rs2> Логический сдвиг вправо Сдвинуть значение первого исходного регистра вправо на количество бит, указанное во втором исходном регистре, и сохранить результат в целевом регистре.
    rd <- rs1 >> rs2

sra <rd>, <rs1>, <rs2> Арифметический сдвиг вправо Арифметический сдвиг вправо Сдвинуть значение первого исходного регистра вправо на количество бит, указанное во втором исходном регистре, сохраняя знак, и сохранить результат в целевом регистре.
    rd <- rs1 >> rs2

and <rd>, <rs1>, <rs2>  Выполнение побитовой операции «И» над значениями двух исходных регистров и сохранение результата в целевом регистре.
    rd <- rs1 & rs2

or <rd>, <rs1>, <rs2>   Выполнение побитовой операции ИЛИ над значениями двух исходных регистров и сохранение результата в целевом регистре.
    rd <- rs1 | rs2

xor <rd>, <rs1>, <rs2>  Выполнение побитовой операции XOR над значениями двух исходных регистров и сохранение результата в целевом регистре.
    rd <- rs1 ^ rs2

j <k>   Прыжок  Переход к адресу, вычисленному путем прибавления текущего значения к текущему счетчику программ.
    pc <- pc + k

jal <rd>, <k>   Перейти и перейти по ссылке Сохранение адреса следующей инструкции в регистре назначения и переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ.
    rd <- pc + 4, pc <- pc + k

jr <rs>         Перейти к регистрации   Переход к адресу, сохранённому в исходном регистре.
    pc <- rs

beqz <rs1>, <k> Переход, если равно нулю    Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в исходном регистре равно нулю.
    if rs1 == 0 then pc <- pc + k

bnez <rs1>, <k> Переход, если не равно нулю Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в исходном регистре не равно нулю
    if rs1 != 0 then pc <- pc + k

bgt <rs1>, <rs2>, <k>       Ветвь, если больше  Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре больше значения во втором исходном регистре
    if rs1 > rs2 then pc <- pc + k

ble <rs1>, <rs2>, <k>       Переход, если меньше или равно  Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре меньше или равно значению во втором исходном регистре.
    if rs1 <= rs2 then pc <- pc + k

bgtu <rs1>, <rs2>, <k>      Переход, если больше (без знака)    Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если беззнаковое значение в первом исходном регистре больше беззнакового значения во втором исходном регистре.
    if rs1 > rs2 then pc <- pc + k

bleu <rs1>, <rs2>, <k>      Переход, если меньше или равно (без знака)  Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если беззнаковое значение в первом исходном регистре меньше или равно беззнаковому значению во втором исходном регистре
    if rs1 <= rs2 then pc <- pc + k

beq <rs1>, <rs2>, <k>       Ветвь, если равно   Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре равно значению во втором исходном регистре
    if rs1 == rs2 then pc <- pc + k

bne <rs1>, <rs2>, <k>       Ветвь, если не равно    Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре не равно значению во втором исходном регистре
    if rs1 != rs2 then pc <- pc + k

halt    Остановите машину

Доступные регистры: Zero, Ra, Sp, Gp, Tp, T0, T1, T2, S0Fp, S1, A0, A1, A2, A3, A4, A5, A6, A7, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, T3, T4, T5.T6












