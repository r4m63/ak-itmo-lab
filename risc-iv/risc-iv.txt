def count_ones(n):
    """Count the number of ones in the binary representation of a number"""
    count = 0
    while n > 0:
        count += n & 1
        n >>= 1
    return count


assert count_ones(5) == 2
assert count_ones(7) == 3
assert count_ones(247923789) == 13
assert count_ones(2147483647) == 31




Эти директивы обычно используются вместе для загрузки полного 32-битного адреса в регистр:
```
lui  a0, %hi(address)    ; Load upper 20 bits into a0
addi a0, a0, %lo(address) ; Add lower 12 bits to a0
```
%hi(symbol)             Используется для извлечения старших 20 бит 32-битного адреса или непосредственного значения
                        Использование: lui rd, %hi(symbol)
                        Операция: rd <- (symbol & 0xFFFFF000)
%lo(symbol)             Используется для извлечения младших 12 бит 32-битного адреса или непосредственного значения
                        Использование: addi rd, rs, %lo(symbol)
                        Операция: rd <- rs + (symbol & 0x00000FFF)

Размер инструкции: 4 байта.

lui <rd>, <k>       Загрузка непосредственного значения, сдвинутого влево на 12 бит, в регистр назначения.      rd <- k << 12
mv <rd>, <rs>       Переместить значение из исходного регистра в целевой регистр.       rd <- rs
sw <rs2>, <offset>(<rs1>)       Сохранение значения из исходного регистра в памяти по адресу, вычисленному путем прибавления смещения к базовому регистру.      M[offset + rs1] <- rs2
sb <rs2>, <offset>(<rs1>)       Сохранение младших 8 бит значения из исходного регистра в памяти по адресу, вычисленному путем прибавления смещения к базовому регистру.    M[offset + rs1] <- rs2 & 0xFF
lw <rd>, <offset>(<rs1>)    Загрузка слова из памяти по адресу, вычисленному путем добавления смещения к базовому регистру в регистр назначения.    rd <- M[offset + rs1]
addi <rd>, <rs1>, <k>   Добавить непосредственное значение в исходный регистр и сохранить результат в регистре назначения. Сохраняются только нижние 12 бит результата (верхние 20 бит устанавливаются в зависимости от знака непосредственного значения).  rd <- rs1 + k
add <rd>, <rs1>, <rs2>  Сложить значения двух исходных регистров и сохранить результат в целевом регистре.  rd <- rs1 + rs2
sub <rd>, <rs1>, <rs2>  Вычесть значение второго исходного регистра из значения первого исходного регистра и сохранить результат в целевом регистре.    rd <- rs1 - rs2
mul <rd>, <rs1>, <rs2>  Умножение значений двух исходных регистров и сохранение результата в целевом регистре.  rd <- rs1 * rs2
mulh <rd>, <rs1>, <rs2> Умножить значения двух исходных регистров и сохранить старшую часть результата в целевом регистре.      rd <- (rs1 * rs2) >> (word size)
div <rd>, <rs1>, <rs2>  Разделить значение первого исходного регистра на значение второго исходного регистра и сохранить результат в целевом регистре.  rd <- rs1 / rs2
rem <rd>, <rs1>, <rs2>  Вычислить остаток от деления первого исходного регистра на второй исходный регистр и сохранить результат в целевом регистре.    rd <- rs1 % rs2

sll <rd>, <rs1>, <rs2> Логический сдвиг влево Сдвиг значения первого исходного регистра влево на количество бит, указанное во втором исходном регистре, и сохранение результата в целевом регистре. rd <- rs1 << rs2
srl <rd>, <rs1>, <rs2> Логический сдвиг вправо Сдвинуть значение первого исходного регистра вправо на количество бит, указанное во втором исходном регистре, и сохранить результат в целевом регистре.  rd <- rs1 >> rs2
sra <rd>, <rs1>, <rs2> Арифметический сдвиг вправо Арифметический сдвиг вправо Сдвинуть значение первого исходного регистра вправо на количество бит, указанное во втором исходном регистре, сохраняя знак, и сохранить результат в целевом регистре.  rd <- rs1 >> rs2
and <rd>, <rs1>, <rs2>  Выполнение побитовой операции «И» над значениями двух исходных регистров и сохранение результата в целевом регистре.    rd <- rs1 & rs2
or <rd>, <rs1>, <rs2>   Выполнение побитовой операции ИЛИ над значениями двух исходных регистров и сохранение результата в целевом регистре.    rd <- rs1 | rs2
xor <rd>, <rs1>, <rs2>  Выполнение побитовой операции XOR над значениями двух исходных регистров и сохранение результата в целевом регистре.    rd <- rs1 ^ rs2

j <k>   Прыжок  Переход к адресу, вычисленному путем прибавления текущего значения к текущему счетчику программ.    pc <- pc + k
jal <rd>, <k>   Перейти и перейти по ссылке Сохранение адреса следующей инструкции в регистре назначения и переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ. rd <- pc + 4, pc <- pc + k
jr <rs>         Перейти к регистрации   Переход к адресу, сохранённому в исходном регистре.  pc <- rs
beqz <rs1>, <k> Переход, если равно нулю    Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в исходном регистре равно нулю. if rs1 == 0 then pc <- pc + k
bnez <rs1>, <k> Переход, если не равно нулю Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в исходном регистре не равно нулю if rs1 != 0 then pc <- pc + k
bgt <rs1>, <rs2>, <k>       Ветвь, если больше  Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре больше значения во втором исходном регистре   if rs1 > rs2 then pc <- pc + k
ble <rs1>, <rs2>, <k>       Переход, если меньше или равно  Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре меньше или равно значению во втором исходном регистре.    if rs1 <= rs2 then pc <- pc + k
bgtu <rs1>, <rs2>, <k>      Переход, если больше (без знака)    Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если беззнаковое значение в первом исходном регистре больше беззнакового значения во втором исходном регистре.     if rs1 > rs2 then pc <- pc + k
bleu <rs1>, <rs2>, <k>      Переход, если меньше или равно (без знака)  Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если беззнаковое значение в первом исходном регистре меньше или равно беззнаковому значению во втором исходном регистре    if rs1 <= rs2 then pc <- pc + k
beq <rs1>, <rs2>, <k>       Ветвь, если равно   Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре равно значению во втором исходном регистре   if rs1 == rs2 then pc <- pc + k 
bne <rs1>, <rs2>, <k>       Ветвь, если не равно    Переход к адресу, вычисленному путем добавления непосредственного значения к текущему счетчику программ, если значение в первом исходном регистре не равно значению во втором исходном регистре     if rs1 != rs2 then pc <- pc + k

halt    Остановите машину

Доступные регистры: Zero, Ra, Sp, Gp, Tp, T0, T1, T2, S0Fp, S1, A0, A1, A2, A3, A4, A5, A6, A7, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, T3, T4, T5.T6












