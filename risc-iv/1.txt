    .data
input_address:   .word  0x80
output_address:  .word  0x84

    .text

_start:

; Загрузка адреса input_address
; Собираем 32-битный адрес input_address в регистре t0
    lui      t0, %hi(input_address)          ; t0 = 0
                                                ; lui (Load Upper Immediate) загружает старшие 20 бит адреса input_address в t0, сдвигая их на 12 бит влево.
                                             ; lui (Load Upper Immediate) — берёт старшие 20 бит адреса input_address, сдвигает их на 12 бит влево и кладёт в t0.
                                             ; Если input_address = 0x80, то %hi(0x80) = 0x00000 (потому что 0x80 — это 0x00000080, старшие 20 бит нулевые).
                                             ; После lui t0 будет t0 = 0x00000000.
    addi     t0, t0, %lo(input_address)      ; t0 <- 80
                                        ; addi добавляет младшие 12 бит, формируя полный 32-битный адрес input_address.
                                            ; addi — добавляет младшие 12 бит адреса (%lo(0x80) = 0x080).
                                            ; Теперь t0 = 0x00000080 (полный адрес input_address).
                                        ; Зачем так сложно?
                                        ; Потому что в RISC-V нельзя загрузить 32-битный адрес одной командой. Делаем это за два шага.

; Получение входного числа
    lw       t0, 0(t0)                  ; t0 = *input_address        ; загружает указатель на входное слово (который хранится в input_address). Если input_address содержит 0x80, то после первой lw регистр t0 станет равен 0x80.
                                        ; Первая lw (Load Word):
                                        ; Читает 4 байта из памяти по адресу t0 (то есть из input_address).
                                        ; В input_address лежит число 0x80 — значит, t0 = 0x80 после первой lw.
    lw       t0, 0(t0)                  ; t0 = *t0        ; загружает само входное слово по адресу 0x80
                                        ; Вторая lw:
                                        ; Читает 4 байта по адресу 0x80 (теперь t0 — это само входное число).
                                        ; Допустим, по адресу 0x80 лежит 0x12345678 — тогда t0 = 0x12345678.

; Подготовка к подсчёту единиц
    addi     t1, zero, 1                        ; t1 — это битовая маска, которая будет сдвигаться для проверки каждого бита.
    addi     t4, zero, 1                        ; t4 — константа 1, которая будет прибавляться к счётчику (t3), если бит установлен.
                                        ; t1 — это "маска". Начинаем с 1 (0b000...0001), потом будем сдвигать её влево.
                                        ; t4 — просто константа 1 для увеличения счётчика.
                                        ; zero — это всегда ноль (в RISC-V x0 = zero).
loop:
    beqz     t1, end                            ; Если маска == 0, выходим из цикла, Если t1 == 0, значит, все биты проверены, и мы переходим к end.
                                        ; Если t1 (наша маска) стала нулём — значит, проверили все 32 бита. Выходим из цикла.
    and      t2, t0, t1                         ; t2 = t0 & t1 (проверяем текущий бит), Побитовое И между t0 (входное слово) и t1 (маска). Если результат t2 != 0, значит, текущий бит в t0 установлен в 1.
                                        ; and делает побитовое И между числом t0 и маской t1.
                                        ; Если результат t2 != 0 — значит, текущий бит в t0 равен 1.
                                        ; Пример:
                                        ; Пусть t0 = 0b...1010, t1 = 0b0010.
                                        ; Тогда t2 = 0b1010 & 0b0010 = 0b0010 (не ноль → бит установлен).
    sll      t1, t1, t4                         ; Сдвигаем маску влево (t1 = t1 << 1), Сдвигаем маску влево на 1 бит (t1 = t1 << 1), чтобы проверить следующий бит. Например, если t1 был 0b0001, то после сдвига станет 0b0010.
                                        ; sll (Shift Left Logical) сдвигает t1 влево на t4 (то есть на 1 бит).
                                        ; Было t1 = 0b0001 → станет 0b0010 → 0b0100 → и так далее.
    beqz     t2, loop                           ; Если бит == 0, пропускаем инкремент Если t2 == 0 (бит не установлен), возвращаемся в начало цикла
                                        ; Если t2 == 0 (бит был 0), просто переходим на следующую итерацию.
    add      t3, t3, t4                         ; Иначе увеличиваем счётчик (t3 += 1), Если бит установлен (t2 != 0), увеличиваем счётчик t3 на 1
                                        ; Если бит был 1 (t2 != 0), увеличиваем t3 на 1.
    j        loop                               ; Переход на следующую итерацию, Безусловный переход на следующую итерацию
end:    ; Сохранение результата
    lui      t0, %hi(output_address)            ; t0 = 0 ; Загружаем полный адрес output_address в t0 (аналогично input_address)
    addi     t0, t0, %lo(output_address)        ; t0 <- 84 ; Загружаем полный адрес output_address в t0 (аналогично input_address).
    lw       t0, 0(t0)                          ; t0 = *output_address ; Загружаем указатель на место, куда нужно сохранить результат (например, 0x84).
    sw       t3, 0(t0)                          ; *t0 = t3 (answer) ; Сохраняем значение t3 (количество единиц) по адресу 0x84
    halt
